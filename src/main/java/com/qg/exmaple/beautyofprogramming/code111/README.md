## 编程之美读书笔记之1.11~1.13

### 1.11 一排石头的游戏

#### (1) 问题：

一堆石头排成一排，两个人轮流从其中抓取一块或两块石头(两块石头必须是挨着的)，谁拿到了最后的石头，谁就是赢家。

#### (2)  思路：

假设有三块石头，则先拿中间的一块。

如果有四块石头，则先拿中间的两块。

再扩展一下，如果有五块石头，甲先拿中间的一块，如果下面乙拿一块，甲就拿和乙中心对称的一块，这样甲还是会赢。

#### (3) 规律：

如果是奇数块石头，则先取中间一块；如果是偶数块石头，则先取中间两块，剩下的只要和对手所取的石头保持基于中心点对称，就一定可以获胜。**先取必有必胜的策略**。

#### (4) 扩展问题 1

**修改规则：取到最后一块石头的人输**

| O    | 策略方法                                  | 结构                    |
| ---- | ------------------------------------- | --------------------- |
| 1    | 1                                     | 先取必输                  |
| 2    | 1+1                                   | 先取必赢                  |
| 3    | 2+1                                   | 先取必赢                  |
| 4    | 1+3 、2+2                              | 先取必赢                  |
| 5    | 4x、1x3、2x2、3xx、1xx2                   | (后取)输、赢、输、赢、赢         |
| 6    | 5x、1x4、2x3、4xx、1xx3、2xx2              | (后取)赢、赢、赢、输、赢、输       |
| 7    | 6x、1x5、2x4、3x3、5xx、1xx4、2xx3          | (后取)赢、输、赢、输、赢、赢、赢     |
| 8    | 7x、1x6、2x5、3x4、6xx、1xx5、2xx4、3xx3     | (后取)赢、赢、赢、输、赢、输、赢、输   |
| 9    | 8x、1x7、2x6、3x5、4x4、7xx、1xx6、2xx5、3xx4 | (后取)赢、赢、赢、赢、赢、赢、赢、赢、赢 |

**举例说明：**

2+2，表示先取2块石头(编号为1和2)，再取两块石头(编号为3和4);

1x3:，表示先取一块石头，编号为2；3xx，表示先取两块石头，编号为4和5。

**综上，并没有策略可以保证一定可以获胜。**

#### (5) 扩展问题 2

**修改规则：若没人每次最少取一块石头，最多取k块石头。**

若有1~k块石头，则先取必赢；

若有k+1块石头，则后取必赢；

若有k+2 ~ 2(k+1)块石头，通过将取数石头块数变为k+1，则先取必赢。

综上，

**若有n(k+1)块石头，通过保证每次取的个数位 (k+1)-对手取数<两次取数总和为k+1>，从而保证后取必赢。**

**若有n(k+1)+m块石头，且0<m<k+1，则先取必赢。**

### 1.12

#### (1) 问题

有N块石头和两个玩家A和B，玩家A先将石头随机分成若干堆，然后按照BABA...的顺序不断轮流取石头， 能将剩下的石头一次取光的玩家获胜，每次取石头时，每个玩家只能从若干堆石头中任选一堆， 取这一堆石头中任意数目（大于0）个石头。 

请问 : 玩家A要怎样分配和取石头才能保证自己有把握取胜？ 

#### (2) 思路

##### 如果石头块数为偶数

从最小个数情况出发，石头分配为为(1,1)，这样子A必赢。

如果 N>=4，由于是B先拿，我们只要将局面控制最后归为(1,1)，这样子A就能取得胜利。由(1,1)往上推算可以很快得到(X,X)仍然处于对A必赢的局面。

因此，我们可以得出结论：A只要将其分为相同的两份，就一定能取胜。 

##### 如果石头块数为奇数

这里采用异或的思路。需要提到书上的三个结论：

1. 当有奇数个石头时，无论如何分堆，总有XOR(M1,M2,……Mn) != 0;
2. 当XOR(M1,M2,……Mn) != 0 时，只要改变一个 M 的值，就可以得到 XOR(M1,M2,…Mi,…Mn) = 0;
3. 当XOR(M1,M2,……Mn) = 0 时，只要改变一个 M 的值，就可以得到 XOR(M1,M2,…Mi,…Mn) != 0;

```
游戏流程如下：
初始：XOR(M1, M2, ... , Mn) != 0 
玩家B：XOR(M1, ... , Mi', ... , Mn) == 0 （其中一堆Mi的个数减少到Mi'）
玩家A：XOR(M1, ... , Mj', ... , Mn) != 0 
玩家B：XOR(M1, ... , Mi', ... , Mn) == 0 （其中一堆Mi的个数减少到Mi'） 
…………
结果：XOR(M1, ... , Mj' , ... , Mn) == 0 （直到结束状态(0,0)）
```

解题思路：

令xor=XOR(M1,M2,...Mi-1,Mi,Mi+1,...Mn); 

Mi'=Mi^xor=XOR(M1,M2,...Mi-1,Mi+1,...Mn) ;

那么XOR(M1,M2,...Mi-1,Mi',Mi+1,...Mn)=0 。

#### (3) 解法

1. 将现有的数组进行或与操作，得到结果 n。
2. 若 n != 0，则从现有数组中进行查找，找到一个大于 n 的元素进行减法操作(在代码中表现形式有点不同但最终思路是一样的)。

### 1.13

#### (1) 问题

假设有两堆石头，有两个玩家会根据如下的规则轮流取石头：每人每次可以从两堆石头中各取出数量相等的石头，或者仅从一堆石头中取出任意数量的石头；最后把剩下的石头一次拿光的人获胜。请问在哪些局面（依据两堆石头中的石头个数）下，先取石头的玩家有必胜的策略。

#### (2) 思路


**解法 1 : **

根据题目提示，(1,2) 先取者必输，考虑到2-1=1，所有满足（k+1，k+2）(k>0)，（1，k）（此处k≠2），（2，k）（此处k>1）的情况先取者都能获胜。然后分析差值为2的情况，首先想到的是（3,5），此处没有用到之前的数字1、2，分析可知先取者必输，同理分析差值为3且跟之前数字不重复的情况为（4,7），以此类推，能够获得必输集合中所有元素。

**解法 2 : **

具体推理证明见书中详解！

#### (3) 推论

**解法 1 : **

1. a1 = 1, b1 = 2;
2. 若a1、b1、……a(n-1)、b(n-1)已经求得，则a(n)为未出现在这个队列中的最小整数;
3. b(n) = a(n) + n。

**解法 2 :**

```
	a(n) = [a * n], b(n) = [b * n];		// [] 表示对一个数取下整数
	a = (1 + sqrt(5)) / 2;
	b = (3 + sqrt(5)) / 2;
```

#### (4) 扩展问题 1

**如何求当前局面下一步获胜的策略？**

从当前局面出发，根据原题判断其当前是否处于安全局面，再枚举可能性取法并再次进行判断，如此反复，找到第一个不安全局面留给对手。

#### (5) 扩展问题 2

**修改规则 : **

```
两个玩家，只有一堆石头，两人依次拿石头，最后拿光者为赢家。取石头的规则是：
1. 第一个玩家不能拿光所有的石头。
2. 第一次拿石头之后，每人每次最多只能拿掉对方前一次所拿石头的两倍。
求解是否存在必胜算法？
```

**分析 : **

```json
f(2) = n = 2 = 1 + 1;			// 输
f(3) = n = 3 = 1 + 2;			// 输
f(4) = n = 4 = 1 + f(3);		// 赢
f(5) = n = 5 = 1 + f(4);		// 输
f(6) = n = 6 = 1 + f(5);		// 赢
………………
```

所以，可以得到 `f(n) = i + f(n - i)`。

所以可得，不能获胜的数组为:

````
[1]、[1]、2、3、5、8、13 ………… // Fibonacci 数列
````

**结论 : **

直接构造 Fibonacci 数列，并与当前数进行比较，就可以判断当前是否存在有必胜策略。

